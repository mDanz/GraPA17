#version 440
 
layout(quads, equal_spacing, cw) in;

in vec3 tcPosition[];

uniform mat4 mvMatrix;
uniform mat4 projMatrix;

uniform sampler2D heightMap;
uniform float terrainHeightScale;
uniform float totalTerrainWidth;

out vec3 posInWorld;
out vec3 posInView;
out float height;
out vec3 normal;

//quad interpol
vec3 interpolate(in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3)
{
 vec3 a = mix(v0, v1, gl_TessCoord.x);
 vec3 b = mix(v3, v2, gl_TessCoord.x);
 return mix(a, b, gl_TessCoord.y);
}
 
void main()
{ 
	vec3 tePosition = interpolate(gl_in[0].gl_Position.xyz, gl_in[1].gl_Position.xyz, gl_in[2].gl_Position.xyz, gl_in[3].gl_Position.xyz);
	//vec2 uv = gl_Position.xz;

	//vec3 tePosition = interpolate(tcPosition[0], tcPosition[1], tcPosition[2], tcPosition[3]);

    // sample the height
	vec2 totalSize = vec2(totalTerrainWidth, totalTerrainWidth);
    vec2 uv = (tePosition.xz+(totalSize/2.f))/totalSize;

    int lod = 0;
    height = textureLod(heightMap, uv, lod).r;
    //height = terrainHeightScale;
    tePosition.y = height * terrainHeightScale;
    posInWorld = tePosition;
    posInView = (mvMatrix * vec4(tePosition, 1)).xyz;

    // calculate the normal from the heightmap
    vec2 size = textureSize(heightMap, lod);
    float step = (1.f/size.x + 1.f/size.y)/2.f;

    vec3 hx = vec3((uv.x + step) * totalTerrainWidth, terrainHeightScale * textureLod(heightMap, uv + vec2(step, 0.f), lod).r, uv.y * totalTerrainWidth);
    vec3 hz = vec3(uv.x * totalTerrainWidth, terrainHeightScale * textureLod(heightMap, uv + vec2(0.f, step), lod).r, (uv.y + step)*totalTerrainWidth);

    normal = cross(hz - vec3(uv.x * totalTerrainWidth, terrainHeightScale * height, uv.y * totalTerrainWidth), hx - vec3(uv.x * totalTerrainWidth, terrainHeightScale * height, uv.y * totalTerrainWidth));
    normal = normalize(normal);

	gl_Position = projMatrix * mvMatrix * vec4(tePosition, 1.0f);
}